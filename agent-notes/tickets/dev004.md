# DEV-004: Entity Component System with Controllable Blue Square

## Description
Create a bare-bones Entity Component System (ECS) in the Rust engine and demonstrate it by creating a controllable blue square entity from TypeScript that responds to arrow key input.

## Problem Statement
The current triangle application has hardcoded graphics with no entity abstraction. To support the game design pattern, we need:
1. **Entity Management**: Create, track, and render multiple game objects
2. **Component System**: Modular properties like position, rendering, and input handling
3. **TypeScript Entity Creation**: Game logic can spawn entities dynamically
4. **Input Integration**: Entities can be marked as controllable with keyboard input

## Solution Overview
Build a minimal ECS that supports entities with position, rendering, and controllable components. Replace the hardcoded triangle with an entity system and demonstrate by creating a blue square from TypeScript that moves with arrow keys.

## Requirements

### 1. Entity Component System Core
- **Entity ID Management**: Unique identifiers for game objects
- **Component Storage**: Position, Render, and Controllable components
- **System Processing**: Update and render loops for components
- **Memory Management**: Efficient storage and cleanup of entities

### 2. Component Types
```rust
// Position component - where the entity is located
pub struct Position {
    pub x: f32,
    pub y: f32,
}

// Render component - visual representation
pub struct Render {
    pub size: [f32; 2],        // width, height
    pub color: [f32; 3],       // RGB color
    pub shape: RenderShape,    // Square, Circle, etc.
}

// Controllable component - responds to input
pub struct Controllable {
    pub movement_speed: f32,   // pixels per second
    pub input_type: InputType, // ArrowKeys, WASD, etc.
    pub bounds: BoundsType,    // Screen, None, Custom
}
```

### 3. TypeScript Entity API
- **Create Entity**: `Engine.createEntity(components)` returns EntityID
- **Component Assignment**: Attach Position, Render, Controllable components
- **Runtime Validation**: Type checking and error handling for invalid component data

## Technical Implementation

### 1. ECS Architecture
```rust
pub struct EntityManager {
    entities: Vec<EntityId>,
    positions: HashMap<EntityId, Position>,
    renders: HashMap<EntityId, Render>, 
    controllables: HashMap<EntityId, Controllable>,
    next_id: u32,
}

impl EntityManager {
    pub fn create_entity(&mut self) -> EntityId;
    pub fn add_component<T>(&mut self, entity: EntityId, component: T);
    pub fn remove_entity(&mut self, entity: EntityId);
}

// Systems that process components
pub struct MovementSystem;
impl MovementSystem {
    pub fn update(&mut self, entities: &mut EntityManager, input: &InputState, delta_time: f32);
}

pub struct RenderSystem;
impl RenderSystem {
    pub fn render(&mut self, entities: &EntityManager, renderer: &mut Renderer);
}
```

### 2. TypeScript Integration
```rust
// Deno ops for entity creation
#[op2]
fn op_create_entity() -> u32 {
    let entity_id = ENGINE_STATE.entities.create_entity();
    entity_id
}

#[op2]
fn op_add_position(#[serde] entity_id: u32, #[serde] x: f32, #[serde] y: f32) -> bool {
    ENGINE_STATE.entities.add_component(entity_id, Position { x, y });
    true
}

#[op2]
fn op_add_render(#[serde] entity_id: u32, #[serde] props: RenderProps) -> bool {
    ENGINE_STATE.entities.add_component(entity_id, Render::from(props));
    true
}

#[op2] 
fn op_add_controllable(#[serde] entity_id: u32, #[serde] props: ControllableProps) -> bool {
    ENGINE_STATE.entities.add_component(entity_id, Controllable::from(props));
    true
}
```

### 3. Test TypeScript Script
```typescript
// create_blue_square.ts
declare global {
    function createEntity(): number;
    function addPosition(entityId: number, x: number, y: number): boolean;
    function addRender(entityId: number, props: {
        size: [number, number],
        color: [number, number, number],
        shape: string
    }): boolean;
    function addControllable(entityId: number, props: {
        movementSpeed: number,
        inputType: string,
        bounds: string
    }): boolean;
}

console.log("Creating controllable blue square...");

// Create entity
const blueSquare = createEntity();

// Add position component (center of screen)
addPosition(blueSquare, 400, 300);

// Add render component (30x30 blue square)
addRender(blueSquare, {
    size: [30, 30],
    color: [0.0, 0.0, 1.0], // Blue
    shape: "square"
});

// Add controllable component (arrow key movement)
addControllable(blueSquare, {
    movementSpeed: 120.0,
    inputType: "arrow_keys", 
    bounds: "screen"
});

console.log(`Blue square entity created with ID: ${blueSquare}`);
console.log("Use arrow keys to move the square!");
```

### 4. Integration with Graphics Pipeline
```rust
// Replace triangle rendering with entity system
impl ApplicationHandler for EngineApp {
    fn window_event(&mut self, event: WindowEvent) {
        match event {
            WindowEvent::KeyboardInput { event, .. } => {
                self.input_state.update(event);
            }
            _ => {}
        }
        self.window.request_redraw();
    }

    fn about_to_wait(&mut self) {
        // Update systems
        self.movement_system.update(&mut self.entities, &self.input_state, self.delta_time);
        
        // Render entities instead of hardcoded triangle
        self.render_system.render(&self.entities, &mut self.renderer);
    }
}
```

## Success Criteria

### Functional Requirements
- [ ] **Entity Creation**: TypeScript can create entities and get valid IDs back
- [ ] **Component Assignment**: Can attach Position, Render, and Controllable components
- [ ] **Blue Square Rendering**: 30x30 blue square appears on screen at specified position
- [ ] **Arrow Key Movement**: Square moves in response to arrow key input
- [ ] **Boundary Checking**: Square stays within screen bounds

### Technical Requirements
- [ ] **Performance**: Maintains 120 FPS with entity system overhead
- [ ] **Memory Safety**: No memory leaks or dangling entity references
- [ ] **Type Safety**: Invalid TypeScript calls handled gracefully
- [ ] **System Architecture**: Clean separation between ECS and graphics rendering

## Testing Strategy

### Manual Verification Tests
1. **Entity Creation**: Blue square appears when TypeScript executes
2. **Movement Test**: Each arrow key moves square in correct direction
3. **Boundary Test**: Square stops at screen edges, doesn't disappear
4. **Performance Test**: Smooth movement with consistent frame rate

### Automated Testing
1. **Component Storage**: Verify entities are stored correctly in hashmaps
2. **Input Processing**: Test movement system with simulated input
3. **Rendering Pipeline**: Ensure render system draws all entities
4. **Memory Management**: Validate no memory leaks over time

## Expected Challenges & Solutions

### Challenge: Coordinate System Integration
- **Problem**: Converting between screen coordinates, world coordinates, and GPU coordinates
- **Solution**: Standardize on screen pixel coordinates internally, convert at GPU boundary
- **Testing**: Verify square appears exactly where TypeScript specifies

### Challenge: Input System Integration
- **Problem**: Current input system is tied to triangle movement
- **Solution**: Decouple input handling from specific entities, route through Controllable components
- **Alternative**: Create input event queue that systems can process

### Challenge: Rendering Multiple Shapes
- **Problem**: Current renderer is hardcoded for triangle vertices
- **Solution**: Dynamic vertex buffer generation based on entity shapes
- **Performance**: Use instanced rendering or geometry batching for multiple squares

## Implementation Plan

### Phase 1: ECS Foundation (2-3 hours)
- [ ] Create EntityManager and component storage
- [ ] Implement basic entity creation and component assignment
- [ ] Add TypeScript ops for entity management

### Phase 2: Component Systems (2-3 hours)
- [ ] Implement MovementSystem for Controllable entities
- [ ] Create RenderSystem for drawing entities
- [ ] Integrate input handling with Controllable components

### Phase 3: Blue Square Demo (1-2 hours)
- [ ] Create TypeScript script for blue square creation
- [ ] Test square rendering and movement
- [ ] Validate boundary checking and performance

## Deliverables

### 1. Entity Component System
- EntityManager with component storage and systems
- Position, Render, and Controllable component types
- MovementSystem and RenderSystem implementations

### 2. TypeScript ECS API
- Entity creation and component assignment ops
- Type-safe component property structures
- Error handling for invalid operations

### 3. Blue Square Demo
- Working TypeScript script that creates controllable square
- Visual verification of ECS functionality
- Performance benchmarks with entity system

### 4. Testing & Documentation
- Test cases for component systems
- Usage examples for entity creation
- Performance comparison with hardcoded triangle

## Time Estimate
5-8 hours for complete implementation, testing, and validation

## Priority
**High** - Core architecture for all game development

## Dependencies
- **DEV-003**: TypeScript integration (prerequisite)
- WGPU rendering pipeline understanding
- Input handling system from DEV-002

## Success Metrics

### Before (Current State)
- Hardcoded triangle with no entity abstraction
- Fixed graphics pipeline with no modularity
- No support for multiple game objects

### After (Target State)  
- **Dynamic Entity System**: Create and manage game objects at runtime
- **Component Architecture**: Modular, reusable component types
- **TypeScript Game Control**: Spawn and configure entities from game logic
- **Controllable Objects**: Entities respond to player input automatically

## Architecture Benefits

This ECS foundation enables:
- **Scalability**: Easily add new component types and systems
- **Performance**: Efficient component storage and processing
- **Modularity**: Game logic focuses on entity composition, not implementation details
- **Testability**: Components and systems can be tested independently

## Created By
Development Agent (DEV-004)

## Created Date
2025-08-30

## Related Tickets
- **DEV-003**: TypeScript integration (prerequisite)
- **DEV-005**: Collision detection system (next step)
- **ARCH-002**: WGPU foundation (base technology)