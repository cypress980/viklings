# DEV-005: Collision Detection System with Hitbox Testing

## Description
Implement a collision detection system with hitbox support in the ECS, and demonstrate it by creating two entities from TypeScript that turn white when their hitboxes collide.

## Problem Statement
The current ECS can create and render entities but has no collision detection capabilities. For game mechanics like the square game win condition, we need:
1. **Hitbox Component**: Define collision areas separate from visual representation
2. **Collision Detection**: Efficient AABB (Axis-Aligned Bounding Box) collision checking
3. **Collision Events**: Callback system when entities collide
4. **TypeScript Integration**: Game logic can register collision handlers

## Solution Overview
Add a Hitbox component and CollisionSystem to the ECS. Demonstrate functionality by creating two squares that turn white when their hitboxes overlap, proving the collision detection works visually.

## Requirements

### 1. Hitbox Component System
```rust
// Hitbox component - collision detection area
pub struct Hitbox {
    pub size: [f32; 2],      // width, height of collision box
    pub offset: [f32; 2],    // offset from entity position (for centered hitboxes)
    pub layer: u32,          // collision layer (for filtering what collides)
    pub active: bool,        // can be disabled temporarily
}

// Collision event data
pub struct CollisionEvent {
    pub entity_a: EntityId,
    pub entity_b: EntityId,
    pub timestamp: f64,
}
```

### 2. Collision Detection System
- **AABB Algorithm**: Efficient axis-aligned bounding box overlap testing
- **Spatial Optimization**: Basic optimization for multiple entities (future: spatial hashing)
- **Event Generation**: Detect collision start/end events
- **Layer Filtering**: Only check collisions between compatible layers

### 3. TypeScript Collision API
- **Add Hitbox**: `addHitbox(entityId, props)` to attach collision detection
- **Register Collision Handler**: `onCollision(entityA, entityB, callback)` for game logic
- **Collision Queries**: Check if entities are currently colliding

## Technical Implementation

### 1. Hitbox Component and System
```rust
// Add to EntityManager
pub struct EntityManager {
    // ... existing components
    hitboxes: HashMap<EntityId, Hitbox>,
    collision_handlers: Vec<CollisionHandler>,
}

pub struct CollisionHandler {
    pub entity_a: EntityId,
    pub entity_b: EntityId,
    pub callback: Box<dyn Fn(CollisionEvent)>,
}

pub struct CollisionSystem;
impl CollisionSystem {
    pub fn update(&mut self, entities: &EntityManager) -> Vec<CollisionEvent> {
        let mut events = Vec::new();
        
        // Get all entities with hitboxes and positions
        let colliders: Vec<_> = entities.hitboxes.keys()
            .filter_map(|&id| {
                entities.positions.get(&id).map(|pos| (id, pos))
            })
            .collect();
            
        // Check all pairs for collision
        for i in 0..colliders.len() {
            for j in (i + 1)..colliders.len() {
                let (id_a, pos_a) = colliders[i];
                let (id_b, pos_b) = colliders[j];
                
                if self.check_collision(entities, id_a, pos_a, id_b, pos_b) {
                    events.push(CollisionEvent {
                        entity_a: id_a,
                        entity_b: id_b,
                        timestamp: get_time(),
                    });
                }
            }
        }
        
        events
    }
    
    fn check_collision(&self, entities: &EntityManager, 
                      id_a: EntityId, pos_a: &Position,
                      id_b: EntityId, pos_b: &Position) -> bool {
        let hitbox_a = entities.hitboxes.get(&id_a).unwrap();
        let hitbox_b = entities.hitboxes.get(&id_b).unwrap();
        
        // Calculate AABB bounds for each entity
        let bounds_a = self.get_aabb_bounds(pos_a, hitbox_a);
        let bounds_b = self.get_aabb_bounds(pos_b, hitbox_b);
        
        // AABB overlap test
        bounds_a.left < bounds_b.right &&
        bounds_a.right > bounds_b.left &&
        bounds_a.top < bounds_b.bottom &&
        bounds_a.bottom > bounds_b.top
    }
}
```

### 2. TypeScript Integration
```rust
// Deno ops for collision system
#[op2]
fn op_add_hitbox(#[serde] entity_id: u32, #[serde] props: HitboxProps) -> bool {
    let hitbox = Hitbox {
        size: [props.width, props.height],
        offset: [props.offset_x, props.offset_y],
        layer: props.layer.unwrap_or(0),
        active: true,
    };
    ENGINE_STATE.entities.add_component(entity_id, hitbox);
    true
}

#[op2]
fn op_register_collision_handler(#[serde] entity_a: u32, #[serde] entity_b: u32) -> u32 {
    // Register collision handler and return handler ID
    let handler_id = ENGINE_STATE.entities.add_collision_handler(entity_a, entity_b);
    handler_id
}

// Collision events need to be processed and sent to TypeScript callbacks
#[op2]
fn op_poll_collision_events() -> Vec<CollisionEventData> {
    // Return any collision events that occurred this frame
    ENGINE_STATE.collision_events.drain(..).collect()
}
```

### 3. Test TypeScript Script
```typescript
// collision_test.ts
declare global {
    function createEntity(): number;
    function addPosition(entityId: number, x: number, y: number): boolean;
    function addRender(entityId: number, props: RenderProps): boolean;
    function addHitbox(entityId: number, props: {
        width: number,
        height: number,
        offsetX?: number,
        offsetY?: number,
        layer?: number
    }): boolean;
    function addControllable(entityId: number, props: ControllableProps): boolean;
    function registerCollisionHandler(entityA: number, entityB: number): number;
    function pollCollisionEvents(): CollisionEvent[];
    function setEntityColor(entityId: number, color: [number, number, number]): boolean;
}

console.log("Creating collision test entities...");

// Create first square (controllable, blue initially)
const square1 = createEntity();
addPosition(square1, 200, 200);
addRender(square1, {
    size: [40, 40],
    color: [0.0, 0.0, 1.0], // Blue
    shape: "square"
});
addHitbox(square1, {
    width: 20,    // Smaller hitbox than visual
    height: 20,
    offsetX: 0,   // Centered
    offsetY: 0
});
addControllable(square1, {
    movementSpeed: 150.0,
    inputType: "arrow_keys",
    bounds: "screen"
});

// Create second square (static, green initially)  
const square2 = createEntity();
addPosition(square2, 400, 300);
addRender(square2, {
    size: [40, 40],
    color: [0.0, 1.0, 0.0], // Green
    shape: "square"
});
addHitbox(square2, {
    width: 20,
    height: 20,
    offsetX: 0,
    offsetY: 0
});

// Register collision between the two squares
const handlerId = registerCollisionHandler(square1, square2);

console.log(`Created squares ${square1} and ${square2}`);
console.log("Move the blue square into the green square to test collision!");
console.log("Both squares will turn white when their hitboxes overlap");

// Collision detection loop (called each frame by engine)
function checkCollisions() {
    const events = pollCollisionEvents();
    
    for (const event of events) {
        if ((event.entityA === square1 && event.entityB === square2) ||
            (event.entityA === square2 && event.entityB === square1)) {
            
            console.log("Collision detected! Squares turning white...");
            
            // Turn both squares white when they collide
            setEntityColor(square1, [1.0, 1.0, 1.0]); // White
            setEntityColor(square2, [1.0, 1.0, 1.0]); // White
        }
    }
}

// Export for engine to call
export { checkCollisions };
```

### 4. Engine Integration
```rust
// In main game loop
impl ApplicationHandler for EngineApp {
    fn about_to_wait(&mut self) {
        // ... existing systems
        
        // Run collision detection
        let collision_events = self.collision_system.update(&self.entities);
        self.collision_events.extend(collision_events);
        
        // Call TypeScript collision handler
        if let Some(runtime) = &mut self.js_runtime {
            runtime.execute_script("<collision>", "checkCollisions();")
                .expect("Failed to run collision check");
        }
        
        // ... rendering
    }
}
```

## Success Criteria

### Functional Requirements
- [x] **Hitbox Creation**: TypeScript can attach hitboxes to entities with custom size/offset
- [x] **Collision Detection**: Engine detects when entity hitboxes overlap
- [x] **Visual Feedback**: Both squares turn white when collision occurs
- [x] **Movement Testing**: Can move controllable square to trigger collision (manual mode)
- [x] **Automated Testing**: Programmatic movement without keyboard requirements
- [x] **Precision**: Only hitbox areas cause collision, not full visual squares

### Technical Requirements
- [x] **Performance**: Collision detection maintains 100+ FPS with instanced rendering
- [x] **Accuracy**: AABB collision detection works correctly for all overlap cases
- [x] **Event System**: Collision events properly delivered to TypeScript callbacks
- [x] **Memory Safety**: No memory leaks from collision handler storage

## Testing Strategy

### Manual Verification Tests
1. **Initial State**: Two squares appear (blue and green) with no collision
2. **Movement Test**: Blue square moves with arrow keys as expected
3. **Collision Trigger**: When squares overlap, both turn white immediately
4. **Hitbox Precision**: Collision only occurs when center areas overlap (not edges)
5. **Performance**: Smooth movement and collision detection at 120 FPS

### Edge Case Testing
1. **Boundary Collisions**: Test collision at screen edges
2. **Rapid Movement**: Fast movement still detects collisions
3. **Multiple Collisions**: Handle multiple collision events per frame
4. **Memory Cleanup**: Remove collision handlers when entities are destroyed

## Expected Challenges & Solutions

### Challenge: Collision Detection Performance
- **Problem**: O(nÂ²) collision checking becomes expensive with many entities
- **Solution**: For now, keep it simple; optimize later with spatial partitioning
- **Monitoring**: Track collision system execution time per frame

### Challenge: Coordinate System Consistency
- **Problem**: Hitbox coordinates must align with render coordinates and screen coordinates
- **Solution**: Use consistent coordinate system throughout (screen pixels)
- **Testing**: Visual verification that hitboxes match expected collision areas

### Challenge: Callback Management
- **Problem**: TypeScript callbacks need to be stored and called from Rust
- **Solution**: Store collision handlers in Rust, poll events from TypeScript
- **Alternative**: Use async messaging if synchronous callbacks prove problematic

## Implementation Plan

### Phase 1: Hitbox Component (2 hours) âœ… COMPLETED
- [x] Add Hitbox component to ECS
- [x] Create TypeScript op for adding hitboxes
- [x] Test hitbox attachment to entities

### Phase 2: Collision Detection (3 hours) âœ… COMPLETED
- [x] Implement AABB collision algorithm
- [x] Create CollisionSystem that runs each frame
- [x] Generate collision events for overlapping entities

### Phase 3: TypeScript Integration (2 hours) âœ… COMPLETED
- [x] Add collision event polling from TypeScript
- [x] Implement color-changing functionality for visual feedback
- [x] Create test script with two colliding squares

### Phase 4: Testing & Polish (1 hour) âœ… COMPLETED
- [x] Verify collision precision and visual feedback
- [x] Test performance impact of collision system (100+ FPS maintained)
- [x] Handle edge cases and error conditions
- [x] Create automated testing without keyboard dependencies

## Deliverables

### 1. Collision Detection System
- Hitbox component with size, offset, and layer properties
- CollisionSystem with AABB overlap detection
- Integration with existing ECS and update loop

### 2. TypeScript Collision API
- Operations for adding hitboxes and registering collision handlers
- Event polling system for collision detection results
- Entity property modification (color changing for testing)

### 3. Collision Test Demo
- Two-square collision test with visual feedback
- Controllable movement to trigger collisions
- Console logging for collision events

### 4. Performance & Testing
- Collision detection benchmarks and performance analysis
- Test cases for collision accuracy and edge cases
- Documentation for collision system usage

## Time Estimate
~~6-8 hours for complete implementation, testing, and validation~~  
**ACTUAL: 8 hours** - Complete implementation with automated testing

## Priority
**High** - Essential for game mechanics and win conditions

## FINAL IMPLEMENTATION SUMMARY

### âœ… Successfully Implemented:

1. **Complete ECS Collision System**:
   - Hitbox component with size, offset, layer, and active properties
   - AABB collision detection algorithm with thread-safe implementation
   - CollisionSystem integrated into main render loop
   - Global state management with proper mutex handling

2. **TypeScript Integration API**:
   - `op_add_hitbox()` - Attach hitboxes to entities
   - `op_poll_collision_events()` - Get collision events each frame  
   - `op_set_entity_color()` - Change entity colors for visual feedback
   - `op_set_entity_position()` - Programmatic entity movement

3. **Automated Testing System**:
   - **collision_demo.ts**: Fully automated test requiring no keyboard input
   - Blue square moves programmatically from x=100 to x=420
   - Collision detection triggers when squares overlap
   - Visual feedback: squares turn WHITE during collision
   - Color restoration: squares return to blue/green when separated

4. **Performance & Multi-Entity Rendering**:
   - Maintains 100+ FPS with collision detection active
   - Instanced rendering system supports multiple entities efficiently
   - Single draw call renders all entities with collision detection

### ðŸŽ¯ Test Results:
- **Movement**: Smooth programmatic movement âœ…
- **Collision Detection**: Accurate AABB overlap detection âœ…  
- **Visual Feedback**: White color change during collision âœ…
- **Separation**: Proper collision end detection âœ…
- **Color Restoration**: Return to original colors âœ…
- **Performance**: 100+ FPS maintained throughout test âœ…

## Dependencies
- **DEV-004**: Entity Component System (prerequisite)
- **DEV-003**: TypeScript integration (prerequisite)
- AABB collision detection algorithm understanding

## Success Metrics

### Before (Current State)
- Entities exist independently with no interaction
- No collision detection or game mechanic capabilities
- Visual feedback limited to static rendering

### After (Target State)
- **Collision Detection**: Entities can detect overlap with customizable hitboxes
- **Event System**: Game logic receives collision notifications
- **Visual Feedback**: Testable collision mechanics with color changes
- **Game Foundation**: Core system for implementing win conditions and mechanics

## Architecture Impact

This collision system enables:
- **Game Mechanics**: Win conditions, damage systems, pickup collection
- **Interactive Elements**: Buttons, triggers, zone detection
- **Physics Foundation**: Basis for more complex physics interactions
- **Spatial Queries**: Finding entities near specific locations

## Created By
Development Agent (DEV-005)

## Created Date
2025-08-30

## Related Tickets
- **DEV-004**: Entity Component System (prerequisite)
- **DEV-006**: Text overlay UI system (next step)
- **Game Implementation**: Future square game win condition (dependent)