# DEV-007: Complete Square Game Implementation

## Description
Use the built ECS, collision detection, and UI systems to implement the complete square game: a controllable blue square that must reach a green goal square to win, with proper win condition detection and user feedback.

## Problem Statement
All the foundational systems are now in place:
- TypeScript integration (DEV-003)
- Entity Component System (DEV-004)  
- Collision detection with hitboxes (DEV-005)
- Text overlay UI system (DEV-006)

Now we need to combine these systems into a cohesive, playable game that demonstrates the full engine architecture working together.

## Solution Overview
Implement the square game designed in `game.ts` using the actual engine APIs that have been built. This serves as both a complete game and a comprehensive test of all engine systems working together.

## Requirements

### 1. Game Entities
- **Player Entity**: Controllable blue square (30x30 pixels) with smaller center hitbox (10x10)
- **Goal Entity**: Static green outline square (40x40 pixels) with center hitbox (20x20)  
- **Precise Win Condition**: Player's center hitbox must overlap goal's center hitbox

### 2. Game Mechanics
- **Movement**: Player moves with arrow keys at 120 pixels/second
- **Boundaries**: Player stays within screen bounds
- **Win Detection**: Collision system triggers when player reaches goal
- **Game Reset**: R key resets player position and game state

### 3. User Interface
- **Instructions**: Display controls and objective when game starts
- **Win Message**: Show victory message with restart instructions
- **Status Updates**: Console logging for game state changes

## Technical Implementation

### 1. Game Initialization Script
```typescript
// square_game.ts - Complete implementation using actual engine APIs
declare global {
    // Entity management
    function createEntity(): number;
    function addPosition(entityId: number, x: number, y: number): boolean;
    function addRender(entityId: number, props: RenderProps): boolean;
    function addHitbox(entityId: number, props: HitboxProps): boolean;
    function addControllable(entityId: number, props: ControllableProps): boolean;
    function setEntityPosition(entityId: number, x: number, y: number): boolean;
    
    // Input handling
    function onKeyPressed(key: string, callback: () => void): void;
    
    // Collision system
    function registerCollisionHandler(entityA: number, entityB: number): number;
    function pollCollisionEvents(): CollisionEvent[];
    
    // UI system
    function showText(text: string, x: number, y: number, options?: TextOptions): number;
    function hideText(elementId: number): boolean;
    function clearUI(): boolean;
    
    // Engine control
    function pauseInput(entityId: number): boolean;
    function resumeInput(entityId: number): boolean;
    function pausePhysics(): boolean;
    function resumePhysics(): boolean;
}

// Game state
let gameWon = false;
let player: number;
let goal: number;
let uiElements: { [key: string]: number } = {};

// Initialize game
function initGame() {
    console.log("Initializing Square Game...");
    
    // Create player entity
    player = createEntity();
    addPosition(player, 50, 50);
    addRender(player, {
        size: [30, 30],
        color: [0.0, 0.0, 1.0], // Blue
        shape: "square"
    });
    addHitbox(player, {
        width: 10,
        height: 10,
        offsetX: 0,
        offsetY: 0
    });
    addControllable(player, {
        movementSpeed: 120.0,
        inputType: "arrow_keys",
        bounds: "screen"
    });
    
    // Create goal entity
    goal = createEntity();
    addPosition(goal, 350, 250);
    addRender(goal, {
        size: [40, 40],
        color: [0.0, 1.0, 0.0], // Green
        shape: "outline"
    });
    addHitbox(goal, {
        width: 20,
        height: 20,
        offsetX: 0,
        offsetY: 0
    });
    
    // Register collision detection
    registerCollisionHandler(player, goal);
    
    // Set up input handlers
    onKeyPressed("KeyR", () => resetGame());
    
    // Show initial UI
    showInitialUI();
    
    console.log(`Game initialized: Player=${player}, Goal=${goal}`);
}

function showInitialUI() {
    uiElements.title = showText("Simple Square Game", 400, 30, {
        fontSize: 20,
        color: [1.0, 1.0, 1.0],
        alignment: "center"
    });
    
    uiElements.instructions = showText("Use arrow keys to move the blue square", 400, 60, {
        fontSize: 14,
        color: [0.8, 0.8, 0.8],
        alignment: "center"
    });
    
    uiElements.objective = showText("Get your center into the green goal to win!", 400, 85, {
        fontSize: 14,
        color: [0.8, 0.8, 0.8],
        alignment: "center"
    });
    
    uiElements.reset = showText("Press R to restart", 10, 570, {
        fontSize: 12,
        color: [0.6, 0.6, 0.6],
        alignment: "left"
    });
}

function checkWinCondition() {
    const collisionEvents = pollCollisionEvents();
    
    for (const event of collisionEvents) {
        if ((event.entityA === player && event.entityB === goal) ||
            (event.entityA === goal && event.entityB === player)) {
            
            if (!gameWon) {
                gameWon = true;
                handleWin();
            }
        }
    }
}

function handleWin() {
    console.log("Player wins! Goal reached.");
    
    // Stop player movement
    pauseInput(player);
    
    // Clear instruction UI
    hideText(uiElements.instructions);
    hideText(uiElements.objective);
    
    // Show win message
    uiElements.winTitle = showText("YOU WIN!", 400, 200, {
        fontSize: 32,
        color: [1.0, 1.0, 0.0], // Yellow
        alignment: "center"
    });
    
    uiElements.winMessage = showText("Great job! You reached the goal.", 400, 240, {
        fontSize: 16,
        color: [1.0, 1.0, 1.0],
        alignment: "center"
    });
    
    uiElements.restartPrompt = showText("Press R to play again", 400, 270, {
        fontSize: 14,
        color: [0.8, 0.8, 0.8],
        alignment: "center"
    });
}

function resetGame() {
    console.log("Resetting game...");
    
    // Pause engine during reset
    pausePhysics();
    
    // Reset game state
    gameWon = false;
    
    // Reset player position
    setEntityPosition(player, 50, 50);
    
    // Re-enable player input
    resumeInput(player);
    
    // Clear all UI and show initial UI
    clearUI();
    showInitialUI();
    
    // Resume engine
    resumePhysics();
    
    console.log("Game reset complete");
}

// Game loop function (called by engine each frame)
function gameUpdate() {
    if (!gameWon) {
        checkWinCondition();
    }
}

// Start the game
initGame();

// Export for engine integration
export { gameUpdate, resetGame };
```

### 2. Engine Integration Points
```rust
// Main game loop integration
impl ApplicationHandler for EngineApp {
    fn about_to_wait(&mut self) {
        // Update all engine systems
        self.movement_system.update(&mut self.entities, &self.input_state, self.delta_time);
        self.collision_system.update(&mut self.entities);
        
        // Call TypeScript game update
        if let Some(runtime) = &mut self.js_runtime {
            runtime.execute_script("<game_update>", "gameUpdate();")
                .expect("Failed to run game update");
        }
        
        // Render everything
        self.render_system.render(&self.entities, &mut self.renderer);
        self.ui_system.render(&mut self.renderer);
    }
}
```

## Success Criteria

### Gameplay Requirements
- [ ] **Player Control**: Blue square moves smoothly with arrow keys
- [ ] **Goal Visibility**: Green goal square clearly visible and distinguishable
- [ ] **Win Detection**: Victory occurs only when player center reaches goal center
- [ ] **Win Feedback**: Clear victory message with restart instructions
- [ ] **Game Reset**: R key properly resets all game state

### Technical Requirements
- [ ] **System Integration**: All engine systems work together seamlessly
- [ ] **Performance**: Maintains 120 FPS throughout gameplay
- [ ] **Error Handling**: Graceful handling of TypeScript errors
- [ ] **Memory Management**: No memory leaks during gameplay or resets

### User Experience Requirements
- [ ] **Clear Instructions**: Player understands objective and controls immediately
- [ ] **Responsive Controls**: Input feels immediate and precise
- [ ] **Visual Clarity**: Easy to distinguish player, goal, and UI elements
- [ ] **Satisfying Win**: Victory condition feels fair and rewarding

## Testing Strategy

### Manual Gameplay Testing
1. **Initial State**: Game starts with player at (50,50), goal at (350,250)
2. **Movement Test**: Each arrow key moves player in correct direction
3. **Boundary Test**: Player cannot move outside screen bounds
4. **Win Condition**: Moving player center into goal center triggers win
5. **Reset Test**: R key resets player position and game state
6. **Multiple Plays**: Can play multiple rounds without issues

### Engine Integration Testing  
1. **System Coordination**: ECS, collision, input, and UI systems work together
2. **Performance Testing**: Smooth gameplay at target frame rate
3. **Memory Testing**: Multiple game cycles without memory growth
4. **Error Recovery**: Handle TypeScript errors gracefully

### Edge Case Testing
1. **Rapid Input**: Fast key presses don't break game state
2. **Collision Precision**: Only center overlap triggers win, not edge contact
3. **Reset During Win**: R key works correctly during win state
4. **UI Updates**: Text overlays update correctly during state changes

## Expected Challenges & Solutions

### Challenge: System Coordination
- **Problem**: Multiple engine systems need to coordinate for game state
- **Solution**: Clear separation of concerns with TypeScript as coordinator
- **Testing**: Verify each system works independently and together

### Challenge: Win Condition Precision
- **Problem**: Collision detection must be precise for hitbox overlap
- **Solution**: Use small, centered hitboxes for both player and goal
- **Validation**: Visual and console logging to verify collision accuracy

### Challenge: State Management
- **Problem**: Game state (won/playing) needs to coordinate input, UI, and collision
- **Solution**: Centralized game state in TypeScript with clear state transitions
- **Testing**: Verify state changes work correctly in all scenarios

## Implementation Plan

### Phase 1: Basic Game Setup (2 hours)
- [ ] Implement game initialization with player and goal entities
- [ ] Test basic movement and rendering
- [ ] Verify entity creation and component assignment

### Phase 2: Win Condition Implementation (2 hours)  
- [ ] Implement collision detection and win condition logic
- [ ] Add win state handling and UI updates
- [ ] Test precision of hitbox collision detection

### Phase 3: Game Reset and Polish (1 hour)
- [ ] Implement reset functionality with proper state cleanup
- [ ] Add final UI polish and console logging
- [ ] Test complete game cycles and edge cases

### Phase 4: Integration Testing (1 hour)
- [ ] Test all engine systems working together
- [ ] Performance testing and optimization
- [ ] Final gameplay testing and validation

## Deliverables

### 1. Complete Square Game
- Fully functional square game using engine systems
- Player entity with arrow key movement and boundary checking
- Goal entity with precise collision detection
- Win condition with proper state management

### 2. Game State Management
- Complete game initialization, play, win, and reset cycle
- Proper coordination between TypeScript game logic and Rust engine
- Clean state transitions and error handling

### 3. User Interface Integration
- Instructional text and game status display
- Win condition feedback with restart prompts
- Clear visual communication of game state

### 4. Engine Integration Validation
- Proof that all engine systems work together effectively
- Performance benchmarks with complete game running
- Foundation for future game development

## Time Estimate
6 hours for complete implementation, testing, and polish

## Priority
**Highest** - Capstone demonstration of complete engine architecture

## Dependencies
- **DEV-003**: TypeScript integration (prerequisite)
- **DEV-004**: Entity Component System (prerequisite)
- **DEV-005**: Collision detection system (prerequisite)  
- **DEV-006**: Text overlay UI system (prerequisite)

## Success Metrics

### Before (Current State)
- Separate engine systems tested independently
- No complete game demonstrating system integration
- Unclear whether architecture vision is viable

### After (Target State)
- **Complete Playable Game**: Square game works from start to finish
- **System Integration**: All engine components coordinate effectively
- **TypeScript Game Logic**: Proves viability of TypeScript-Rust architecture
- **Development Foundation**: Ready for building more complex games

## Architecture Validation

This ticket validates the complete engine architecture:
- **TypeScript Game Logic**: High-level game rules and state management
- **Rust Engine Systems**: Performance-critical operations (rendering, collision, input)
- **Clean API Boundaries**: Clear separation between game logic and engine
- **Extensibility**: Foundation for building additional games and features

Success here proves the viability of the entire Viklings engine architecture and establishes the development pattern for future games.

## Created By
Development Agent (DEV-007)

## Created Date
2025-08-30

## Related Tickets
- **DEV-003** through **DEV-006**: All prerequisite systems
- **Architecture Vision**: Validates TypeScript + Rust engine approach
- **Future Development**: Foundation for additional games and features