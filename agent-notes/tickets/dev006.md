# DEV-006: Multi-Entity Rendering System

## Description
Design and implement a rendering system capable of displaying multiple entities simultaneously, each with individual properties (position, size, color). This is a prerequisite for visual collision detection and other multi-entity game mechanics.

## Problem Statement
The current rendering system can only display a single entity at a time. It uses a single vertex buffer and uniform buffer that gets overwritten for each entity, causing only the last entity processed to be visible. This prevents:

1. **Visual collision testing** - Need to see both entities to verify collision detection
2. **Multi-entity games** - Cannot display multiple players, enemies, objects
3. **Interactive gameplay** - Cannot have controllable entities alongside static objects

## Current System Analysis

### Single-Entity Architecture
```rust
// Current approach (BROKEN for multiple entities)
for entity in entities {
    // This overwrites previous entity data!
    self.queue.write_buffer(&self.vertex_buffer, 0, vertices);
    self.queue.write_buffer(&self.uniform_buffer, 0, uniforms);
    render_pass.draw(0..6, 0..1); // Only last entity visible
}
```

### Core Issues
- **Buffer Overwriting**: Each entity overwrites the previous one's vertex/uniform data
- **Single Draw Call**: One draw call per frame, but multiple buffer updates
- **Race Conditions**: Buffer updates inside render pass cause validation errors
- **No Batching**: Inefficient for multiple similar entities

## Design Options Analysis

### Option 1: Multiple Draw Calls (Simplest)
**Approach**: Update buffers between draw calls, multiple render passes

**Pros:**
- ✅ Simple to implement
- ✅ Reuses existing shaders/pipeline
- ✅ No complex vertex buffer management

**Cons:**
- ❌ Multiple render passes = GPU performance cost
- ❌ Buffer updates between draws = CPU/GPU sync overhead
- ❌ Not scalable to many entities

**Suitable for**: 2-10 entities, prototyping

### Option 2: Instanced Rendering (Most Efficient)
**Approach**: Single vertex buffer, instance buffer with per-entity data

**Pros:**
- ✅ Single draw call for all entities
- ✅ GPU-optimal batching
- ✅ Scales to hundreds of entities

**Cons:**
- ❌ Requires shader modifications (instance attributes)
- ❌ More complex vertex layout setup
- ❌ Higher implementation complexity

**Suitable for**: Many similar entities (particles, tiles, sprites)

### Option 3: Dynamic Vertex Buffer (Balanced) ⭐ RECOMMENDED
**Approach**: Single vertex buffer containing all entity vertices

**Pros:**
- ✅ Single draw call
- ✅ Uses existing shaders
- ✅ Individual entity properties (different sizes/colors)
- ✅ Moderate complexity

**Cons:**
- ❌ Vertex buffer recreation each frame
- ❌ Memory allocation per frame  
- ❌ Less efficient than instancing for many entities

**Suitable for**: 2-50 entities with varying properties ← Perfect for collision demo

## Recommended Implementation: Dynamic Vertex Buffer

### Why This Choice?
- ✅ **Simple Implementation**: Builds on existing vertex system
- ✅ **Individual Entity Properties**: Each entity can have unique size/color
- ✅ **Single Draw Call**: Efficient GPU usage
- ✅ **Collision Demo Ready**: Perfect for 2-entity collision testing
- ✅ **Future Extensible**: Can migrate to instancing later if needed

### Implementation Plan
```rust
fn render(&mut self) -> Result<(), wgpu::SurfaceError> {
    // Get all renderable entities
    let entities = self.get_renderable_entities();
    
    // Build combined vertex buffer
    let mut all_vertices = Vec::new();
    for (entity_id, position, render) in entities {
        let entity_vertices = self.generate_entity_vertices(position, render);
        all_vertices.extend_from_slice(&entity_vertices);
    }
    
    // Update vertex buffer once
    self.queue.write_buffer(&self.vertex_buffer, 0, bytemuck::cast_slice(&all_vertices));
    
    // Single draw call for all entities
    let vertex_count = all_vertices.len();
    render_pass.draw(0..vertex_count, 0..1);
}
```

## Success Criteria

### Before (Current State)
- Only one entity visible at a time
- Last entity processed overwrites others
- Buffer update race conditions

### After (Target State)
- **Multiple Entities**: 2+ entities rendered simultaneously
- **Individual Properties**: Each entity has correct position, size, color
- **Performance**: 120 FPS maintained
- **Collision Ready**: Foundation for visual collision detection

## Implementation Tasks

### 1. Dynamic Vertex Buffer System (4 hours)
- [ ] Implement combined vertex buffer generation
- [ ] Single draw call rendering
- [ ] Test with 2 entities (different colors/positions)

### 2. ECS Integration (2 hours)
- [ ] Integrate with existing EntityManager
- [ ] Support Position + Render components
- [ ] Test entity creation/modification

### 3. Performance & Polish (1 hour)
- [ ] Verify 120 FPS with multiple entities
- [ ] Handle edge cases (0 entities, many entities)
- [ ] Clean up debug logging

### 4. Collision Demo Preparation (1 hour)
- [ ] Render separated blue and green squares
- [ ] Verify movement system works
- [ ] Prepare for DEV-005 collision testing

## Dependencies
- **DEV-004**: Entity Component System (completed)
- **DEV-003**: TypeScript integration (completed)
- Existing WGPU rendering pipeline

## Blocks
- **DEV-005**: Collision Detection Visual Testing (waiting for this ticket)

## Time Estimate
8 hours for complete multi-entity rendering system

## Priority  
**High** - Blocks collision detection and all multi-entity features

## Created By
Development Agent (DEV-006)

## Created Date  
2025-08-30

## WGPU Instanced Rendering Design

### Analysis of Java Implementation
Your Java/OpenGL code uses **individual draw calls** per entity rather than true instancing:
```java
// FlatRenderer.java - Individual draw call approach
for (FlatRenderable item : scene) {
    Model model = item.getModel();
    hudShaderProgram.setUniform("projModelMatrix", projModelMatrix);
    hudShaderProgram.setUniform("color", item.getModel().getMaterial().getColor());
    model.render(); // Separate draw call per entity
}
```

### WGPU True Instanced Rendering Design

#### 1. Instance Buffer Layout
```rust
#[repr(C)]
#[derive(Copy, Clone, Debug, bytemuck::Pod, bytemuck::Zeroable)]
pub struct InstanceData {
    pub position: [f32; 2],    // Entity world position
    pub scale: [f32; 2],       // Entity size/scale
    pub color: [f32; 4],       // RGBA color
}

impl InstanceData {
    const ATTRIBS: [wgpu::VertexAttribute; 3] = [
        wgpu::VertexAttribute {
            offset: 0,
            shader_location: 2, // After position (0) and tex_coords (1)
            format: wgpu::VertexFormat::Float32x2,
        },
        wgpu::VertexAttribute {
            offset: std::mem::size_of::<[f32; 2]>() as wgpu::BufferAddress,
            shader_location: 3,
            format: wgpu::VertexFormat::Float32x2,
        },
        wgpu::VertexAttribute {
            offset: std::mem::size_of::<[f32; 4]>() as wgpu::BufferAddress,
            shader_location: 4,
            format: wgpu::VertexFormat::Float32x4,
        },
    ];
}
```

#### 2. Render Pipeline Modifications
```rust
// Vertex buffer layout - shared quad geometry
let vertex_layout = wgpu::VertexBufferLayout {
    array_stride: std::mem::size_of::<Vertex>() as wgpu::BufferAddress,
    step_mode: wgpu::VertexStepMode::Vertex,
    attributes: &Vertex::ATTRIBS,
};

// Instance buffer layout - per-entity data
let instance_layout = wgpu::VertexBufferLayout {
    array_stride: std::mem::size_of::<InstanceData>() as wgpu::BufferAddress,
    step_mode: wgpu::VertexStepMode::Instance, // Key difference!
    attributes: &InstanceData::ATTRIBS,
};

let render_pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
    vertex: wgpu::VertexState {
        buffers: &[vertex_layout, instance_layout], // Both buffers
        // ...
    },
    // ...
});
```

#### 3. Shader Modifications
```wgsl
// vertex.wgsl - Instance attributes
struct VertexInput {
    @location(0) position: vec2<f32>,
    @location(1) tex_coords: vec2<f32>,
}

struct InstanceInput {
    @location(2) instance_pos: vec2<f32>,
    @location(3) instance_scale: vec2<f32>, 
    @location(4) instance_color: vec4<f32>,
}

@vertex
fn vs_main(
    vertex: VertexInput,
    instance: InstanceInput,
) -> VertexOutput {
    var out: VertexOutput;
    
    // Apply instance transformations
    let scaled_pos = vertex.position * instance.instance_scale;
    let world_pos = scaled_pos + instance.instance_pos;
    
    out.clip_position = transform.proj * vec4<f32>(world_pos, 0.0, 1.0);
    out.color = instance.instance_color;
    out.tex_coords = vertex.tex_coords;
    
    return out;
}
```

#### 4. Render Implementation  
```rust
fn render_entities(&mut self, entities: &[(EntityId, &Position, &Render)]) -> Result<(), wgpu::SurfaceError> {
    // Build instance data
    let instance_data: Vec<InstanceData> = entities.iter().map(|(_, pos, render)| {
        InstanceData {
            position: [pos.x, pos.y],
            scale: [render.size[0], render.size[1]], 
            color: render.color,
        }
    }).collect();
    
    // Update instance buffer
    self.queue.write_buffer(
        &self.instance_buffer, 
        0, 
        bytemuck::cast_slice(&instance_data)
    );
    
    // Single instanced draw call
    render_pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
    render_pass.set_vertex_buffer(1, self.instance_buffer.slice(..));
    render_pass.draw(0..6, 0..instance_data.len() as u32); // 6 vertices, N instances
}
```

### Debugging Strategy

#### 1. WGPU Validation Layers
```rust
// Enable validation in development
let instance = wgpu::Instance::new(wgpu::InstanceDescriptor {
    backends: wgpu::Backends::all(),
    flags: wgpu::InstanceFlags::default() | wgpu::InstanceFlags::DEBUG,
    dx12_shader_compiler: Default::default(),
    gles_minor_version: wgpu::Gles3MinorVersion::Automatic,
});
```

#### 2. Buffer Debugging with Labels
```rust
let instance_buffer = device.create_buffer(&wgpu::BufferDescriptor {
    label: Some("Instance Buffer - DEV006"), // Clear labeling
    size: buffer_size,
    usage: wgpu::BufferUsages::VERTEX | wgpu::BufferUsages::COPY_DST,
    mapped_at_creation: false,
});

// Debug buffer contents
#[cfg(debug_assertions)]
fn debug_instance_buffer(&self, instance_data: &[InstanceData]) {
    for (i, data) in instance_data.iter().enumerate() {
        println!("Instance {}: pos={:?}, scale={:?}, color={:?}", 
                 i, data.position, data.scale, data.color);
    }
}
```

#### 3. RenderDoc Integration
```rust
// Add debug scopes for RenderDoc capture
render_pass.push_debug_group("Multi-Entity Instanced Render");
render_pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
render_pass.set_vertex_buffer(1, self.instance_buffer.slice(..));  
render_pass.draw(0..6, 0..instance_count as u32);
render_pass.pop_debug_group();
```

### Unit Testing Strategy

#### 1. Instance Data Generation Tests
```rust
#[cfg(test)]
mod instance_tests {
    use super::*;

    #[test]
    fn test_instance_data_layout() {
        let data = InstanceData {
            position: [1.0, 2.0],
            scale: [0.5, 0.5], 
            color: [1.0, 0.0, 0.0, 1.0],
        };
        
        // Verify memory layout for GPU
        let bytes = bytemuck::bytes_of(&data);
        assert_eq!(bytes.len(), std::mem::size_of::<InstanceData>());
        
        // Test specific byte patterns
        let pos_bytes = &bytes[0..8];
        assert_eq!(pos_bytes, bytemuck::bytes_of(&[1.0f32, 2.0f32]));
    }

    #[test]
    fn test_multiple_instances() {
        let entities = vec![
            (EntityId(1), Position { x: 0.0, y: 0.0 }, Render::default()),
            (EntityId(2), Position { x: 10.0, y: 5.0 }, Render::default()),
        ];
        
        let instance_data = build_instance_data(&entities);
        assert_eq!(instance_data.len(), 2);
        assert_eq!(instance_data[1].position, [10.0, 5.0]);
    }
}
```

#### 2. Buffer Size Validation Tests  
```rust
#[test]
fn test_instance_buffer_sizing() {
    let max_entities = 1000;
    let required_size = max_entities * std::mem::size_of::<InstanceData>();
    
    // Verify our buffer can hold expected entity count
    assert!(required_size <= 64 * 1024); // 64KB reasonable limit
    
    // Test alignment requirements
    assert_eq!(std::mem::size_of::<InstanceData>() % 16, 0); // GPU alignment
}
```

### Implementation Benefits
- ✅ **True GPU Instancing**: Single draw call for all entities
- ✅ **Individual Properties**: Each entity maintains unique position/color/size  
- ✅ **Performance**: Optimal for 10-1000+ entities
- ✅ **Debugging**: RenderDoc integration + validation layers
- ✅ **Testable**: Comprehensive unit tests for buffer management

### Migration from Current System
1. Add InstanceData struct and vertex attributes
2. Modify shaders to accept instance inputs
3. Create instance buffer alongside existing vertex buffer
4. Update render loop to build instance data and use instanced draw
5. Add debugging and unit tests

This design provides the true instanced rendering you implemented concepts for in Java, optimized for WGPU's capabilities.

## Related Tickets
- **DEV-005**: Collision Detection System (blocked by this)
- **DEV-004**: Entity Component System (prerequisite)