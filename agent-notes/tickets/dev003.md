# DEV-003: TypeScript Integration with Triangle Movement Test

## Description
Integrate deno_core into the WGPU triangle application to enable TypeScript execution, with a simple end-to-end test that moves the triangle to the bottom-right corner of the window when TypeScript code is executed.

## Problem Statement
Currently the WGPU triangle application is purely Rust with no scripting capabilities. To build the envisioned TypeScript game logic layer, we need:
1. **TypeScript Runtime**: Embedded V8 engine via deno_core
2. **Rust-TypeScript Bridge**: Function bindings between languages
3. **Testable Integration**: Verifiable proof that TypeScript can control the graphics engine

## Solution Overview
Add deno_core to the existing triangle application and create a minimal TypeScript API that can modify the triangle's position. The test will move the triangle from its default center position to the bottom-right corner.

## Requirements

### 1. Deno Core Integration
- **Dependency**: Add `deno_core` to Cargo.toml
- **Runtime Setup**: Initialize V8 JavaScript runtime in main application
- **TypeScript Support**: Enable TypeScript compilation within the runtime
- **Error Handling**: Proper error reporting for TypeScript execution failures

### 2. Rust-TypeScript API Bridge
- **Op Registration**: Create deno_core "ops" (operations) callable from TypeScript
- **Triangle Control**: Expose function to modify triangle position from TypeScript
- **Type Safety**: Ensure proper type conversion between Rust and TypeScript

### 3. Test Implementation
- **TypeScript Test Script**: Simple script that moves triangle to bottom-right
- **Visual Verification**: Triangle should visibly move when TypeScript executes
- **Console Output**: Log successful TypeScript execution for debugging

## Technical Implementation

### 1. Cargo.toml Updates
```toml
[dependencies]
# ... existing dependencies
deno_core = "0.305"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
```

### 2. Rust Engine API
```rust
// New engine module
pub struct EngineState {
    triangle_position: [f32; 2],
}

// Deno ops - callable from TypeScript
#[op2]
fn op_move_triangle_to(#[serde] x: f32, #[serde] y: f32) -> bool {
    // Convert screen coordinates to normalized device coordinates
    // Update triangle position in shader uniforms
    true
}

// Initialize TypeScript runtime
fn init_typescript_runtime() -> JsRuntime {
    let mut runtime = JsRuntime::new(RuntimeOptions {
        extensions: vec![
            // Register our ops
        ],
        ..Default::default()
    });
    runtime
}
```

### 3. TypeScript Test Script
```typescript
// test_triangle.ts - embedded in Rust or loaded from file
declare global {
    function moveTriangleTo(x: number, y: number): boolean;
}

console.log("Moving triangle to bottom-right corner...");

// Move to bottom-right (800x600 window -> ~650, ~450 in screen coords)
const success = moveTriangleTo(650, 450);

if (success) {
    console.log("Triangle moved successfully!");
} else {
    console.log("Failed to move triangle");
}
```

### 4. Integration in Main Loop
```rust
// In main.rs application handler
impl ApplicationHandler for TriangleApp {
    fn resumed(&mut self) {
        // ... existing setup
        
        // Initialize TypeScript runtime
        self.js_runtime = Some(init_typescript_runtime());
        
        // Execute test script
        if let Some(runtime) = &mut self.js_runtime {
            let script = include_str!("test_triangle.ts");
            runtime.execute_script("<test>", script).expect("Failed to execute TypeScript");
        }
    }
    
    fn window_event(&mut self, event: WindowEvent) {
        // ... existing event handling with updated triangle position
    }
}
```

## Success Criteria

### Functional Requirements
- [ ] **TypeScript Executes**: No runtime errors when executing TypeScript code
- [ ] **Triangle Moves**: Triangle visually moves from center to bottom-right corner
- [ ] **Console Logging**: TypeScript console.log statements appear in Rust stdout
- [ ] **Performance**: No significant FPS impact from TypeScript integration

### Technical Requirements
- [ ] **Build Success**: Project compiles with deno_core dependency
- [ ] **Runtime Stability**: Application doesn't crash during TypeScript execution
- [ ] **Type Safety**: Proper error handling for invalid TypeScript calls
- [ ] **Memory Management**: No memory leaks from V8 runtime

## Testing Strategy

### Manual Verification
1. **Build and Run**: `cargo run --release`
2. **Visual Check**: Triangle should appear in bottom-right corner instead of center
3. **Console Output**: Should see "Moving triangle..." and "Triangle moved successfully!" messages
4. **Performance**: Should maintain ~120 FPS performance

### Debugging Support
- **TypeScript Errors**: Clear error messages when TypeScript execution fails
- **Position Validation**: Log triangle position coordinates for verification
- **Runtime Health**: Monitor V8 runtime memory usage

## Expected Challenges & Solutions

### Challenge: Coordinate System Translation
- **Problem**: TypeScript uses screen coordinates, shader uses normalized device coordinates
- **Solution**: Convert between coordinate systems in the Rust op function
- **Testing**: Verify triangle appears exactly at bottom-right corner

### Challenge: Shader Uniform Updates
- **Problem**: Triangle position is baked into vertex buffer, not dynamic
- **Solution**: Add position uniform to shader and update it from Rust
- **Alternative**: Modify vertex buffer data dynamically

### Challenge: TypeScript Runtime Performance
- **Problem**: V8 initialization might impact startup time
- **Solution**: Initialize runtime asynchronously or cache compiled scripts
- **Monitoring**: Measure and log initialization and execution times

## Implementation Plan

### Phase 1: Basic Integration (2-3 hours)
- [ ] Add deno_core dependency and basic runtime setup
- [ ] Create minimal op for triangle position modification
- [ ] Test with hardcoded TypeScript string execution

### Phase 2: Triangle Movement (1-2 hours)
- [ ] Modify shader to accept position uniform
- [ ] Implement coordinate system conversion
- [ ] Create and execute test TypeScript script

### Phase 3: Polish & Validation (1 hour)
- [ ] Add proper error handling and logging
- [ ] Verify performance impact is minimal
- [ ] Test edge cases and error conditions

## Deliverables

### 1. Enhanced WGPU Application
- Triangle application with embedded TypeScript runtime
- Dynamic triangle positioning via TypeScript control
- Maintained performance characteristics

### 2. TypeScript Integration Layer
- Deno_core runtime setup and configuration
- Rust-TypeScript API bridge with type safety
- Example TypeScript script demonstrating engine control

### 3. Testing & Documentation
- Visual verification of triangle movement
- Performance benchmarks with TypeScript integration
- Error handling documentation

## Time Estimate
4-6 hours for complete implementation, testing, and validation

## Priority
**High** - Foundation for all subsequent TypeScript game logic development

## Dependencies
- Completed WGPU triangle application (viklings-wgpu)
- Rust development environment with network access for crates.io
- Understanding of deno_core and V8 integration patterns

## Success Metrics

### Before (Current State)
- Pure Rust triangle application with static rendering
- No scripting capabilities or dynamic behavior
- Hard-coded triangle position and properties

### After (Target State)
- **TypeScript-Controlled Graphics**: Triangle position controlled by TypeScript code
- **Runtime Integration**: Working V8 runtime embedded in graphics application
- **Extensible Foundation**: Ready for game logic development in TypeScript
- **Verified Functionality**: Clear visual proof of Rust-TypeScript communication

## Integration with Development Workflow

This ticket establishes the foundational pattern for all subsequent game development:

```typescript
// Future game logic will follow this pattern:
Engine.someOperation(parameters);
// Rust engine executes the operation and updates graphics
```

This creates the architecture needed for the complete game engine vision where TypeScript handles game logic and Rust handles performance-critical engine operations.

## Created By
Development Agent (DEV-003)

## Created Date
2025-08-30

## Related Tickets
- **ARCH-002**: WGPU triangle renderer (foundation)
- **DEV-002**: Triangle movement and input validation (prerequisite)
- **Future DEV-004**: Entity Component System development (dependent)