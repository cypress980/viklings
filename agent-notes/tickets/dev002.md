# DEV-002: Triangle Movement with Input Validation

## Description
Add keyboard input handling to the WGPU triangle application, enabling arrow key movement controls, and implement automated input injection and visual validation using the enhanced screenshot tool from TOOL-002.

## Problem Statement
The current triangle application displays a static rainbow triangle. To advance graphics development and validate agent-assisted workflows, we need:
1. **Interactive Controls**: Arrow keys to move the triangle around the screen
2. **Input Automation**: Agent ability to programmatically send keystrokes 
3. **Visual Validation**: Automated verification that input resulted in expected visual changes
4. **Development Workflow**: Complete cycle of input → capture → validate → iterate

## Solution Overview
Extend the WGPU triangle application with keyboard input handling and create an automated testing framework that can inject inputs and validate visual results using screenshots.

## Requirements

### 1. Triangle Movement Controls
- **Arrow Key Input**: Up/Down/Left/Right arrow keys move triangle in corresponding directions
- **Smooth Movement**: Triangle position updates at consistent speed (e.g., 5 pixels per keypress)
- **Boundary Handling**: Triangle stays within window bounds or wraps around edges
- **Real-time Feedback**: Movement visible immediately in rendered frame

### 2. Input Automation Framework
- **Programmatic Input**: Agent can send keystrokes to the application via command line
- **Input Injection Tool**: Script or utility to send specific key sequences
- **Timing Control**: Configurable delays between inputs for proper processing
- **Input Validation**: Confirmation that keystrokes were received by application

### 3. Visual Validation System
- **Before/After Capture**: Screenshots before and after input to compare changes
- **Position Detection**: Basic analysis to verify triangle moved in expected direction
- **Automated Testing**: Script that sends input and validates visual result
- **Test Scenarios**: Predefined movement sequences for comprehensive testing

## Technical Architecture

### 1. WGPU Application Enhancement
```rust
// Input handling integration
struct TriangleState {
    position: [f32; 2],     // x, y position offset
    movement_speed: f32,    // pixels per keypress
}

// Event handling for keyboard input
impl ApplicationHandler for TriangleApp {
    fn window_event(&mut self, event: WindowEvent) {
        match event {
            WindowEvent::KeyboardInput { event, .. } => {
                if event.state == ElementState::Pressed {
                    match event.logical_key {
                        Key::ArrowUp => self.triangle_state.position[1] -= self.triangle_state.movement_speed,
                        Key::ArrowDown => self.triangle_state.position[1] += self.triangle_state.movement_speed,
                        Key::ArrowLeft => self.triangle_state.position[0] -= self.triangle_state.movement_speed,
                        Key::ArrowRight => self.triangle_state.position[0] += self.triangle_state.movement_speed,
                        _ => {}
                    }
                    self.request_redraw();
                }
            }
            _ => {}
        }
    }
}
```

### 2. Input Automation Tool
```bash
#!/bin/bash
# agent-notes/agent-tools/input-injector.sh

send_keystroke() {
    local app_name="$1"
    local key="$2"
    
    # Use osascript to send keystroke to specific application
    osascript -e "
        tell application \"System Events\"
            tell application process \"$app_name\"
                key code $key
            end tell
        end tell
    "
}

# Key codes for arrow keys
send_keystroke "viklings-wgpu" 126  # Up arrow
send_keystroke "viklings-wgpu" 125  # Down arrow  
send_keystroke "viklings-wgpu" 123  # Left arrow
send_keystroke "viklings-wgpu" 124  # Right arrow
```

### 3. Automated Movement Testing Framework
```bash
#!/bin/bash
# agent-notes/agent-tools/movement-validator.sh

test_movement() {
    local direction="$1"
    local key_code="$2"
    
    # Take baseline screenshot
    ./screenshot.sh "viklings-wgpu" "before-${direction}"
    
    # Send keystroke
    ./input-injector.sh "viklings-wgpu" "$key_code"
    
    # Wait for rendering
    sleep 0.1
    
    # Take after screenshot  
    ./screenshot.sh "viklings-wgpu" "after-${direction}"
    
    # Basic validation (file size change indicates visual difference)
    local before_size=$(stat -f%z "../screenshots/before-${direction}.png")
    local after_size=$(stat -f%z "../screenshots/after-${direction}.png")
    
    if [[ "$before_size" != "$after_size" ]]; then
        echo "✅ Movement detected for $direction"
        return 0
    else
        echo "❌ No movement detected for $direction"
        return 1
    fi
}
```

## Implementation Plan

### Phase 1: Input System Integration (Priority: High)
- [ ] Add winit keyboard event handling to WGPU application
- [ ] Implement triangle position state management
- [ ] Update shader uniforms to support triangle translation
- [ ] Test manual keyboard input in running application

### Phase 2: Input Automation Tools (Priority: High)
- [ ] Create input injection script using AppleScript/System Events
- [ ] Test programmatic keystroke delivery to graphics application
- [ ] Add timing controls and error handling
- [ ] Validate keystrokes are received by application

### Phase 3: Visual Validation Framework (Priority: Medium)
- [ ] Create movement testing script using screenshot tool
- [ ] Implement before/after screenshot comparison
- [ ] Add basic position change detection
- [ ] Create test suite for all movement directions

### Phase 4: Advanced Testing Capabilities (Priority: Low)
- [ ] Implement pixel-level triangle position detection
- [ ] Add movement distance validation
- [ ] Create complex movement sequence testing
- [ ] Performance testing for input responsiveness

## Success Criteria

### Functional Requirements
- [ ] **Arrow Key Response**: Triangle moves in correct direction for each arrow key
- [ ] **Consistent Movement**: Each keypress moves triangle the same distance
- [ ] **Boundary Handling**: Triangle behavior at window edges is predictable
- [ ] **Real-time Updates**: Movement visible within 50ms of keypress

### Automation Requirements
- [ ] **Programmatic Input**: Agent can send arrow keys via command line
- [ ] **Input Reliability**: 95%+ success rate for keystroke delivery
- [ ] **Visual Validation**: Automated detection of triangle position changes
- [ ] **Test Automation**: Complete test cycles without human intervention

### Agent Integration Requirements
- [ ] **Workflow Integration**: Input → Screenshot → Validate cycle works seamlessly
- [ ] **Error Detection**: Clear feedback when input/movement fails
- [ ] **Performance**: Complete test cycle completes within 5 seconds
- [ ] **Repeatability**: Consistent results across multiple test runs

## Testing Strategy

### Manual Validation Tests
1. **Basic Movement**: Test each arrow key manually with running application
2. **Boundary Testing**: Move triangle to window edges
3. **Rapid Input**: Test multiple quick keypresses
4. **Focus Testing**: Ensure application maintains input focus

### Automated Test Scenarios
1. **Single Direction Tests**: One keystroke in each direction with validation
2. **Movement Sequences**: Up-Right-Down-Left triangle movement patterns
3. **Boundary Tests**: Movement sequences that reach window edges
4. **Stress Tests**: Rapid keystroke sequences with validation

### Visual Validation Tests
1. **Position Change Detection**: Verify triangle moved from baseline position
2. **Direction Accuracy**: Confirm movement direction matches input direction
3. **Distance Consistency**: Validate consistent movement distance per keypress
4. **Screenshot Quality**: Ensure captures are clear and usable for analysis

## Expected Challenges & Solutions

### Challenge: Application Focus Management
- **Problem**: Keystroke injection requires application to have input focus
- **Solution**: Use AppleScript to activate application before sending keys
- **Fallback**: Add focus validation and automatic focus restoration

### Challenge: Timing Synchronization
- **Problem**: Screenshots taken before movement completes
- **Solution**: Add configurable delays and render completion detection
- **Alternative**: Use frame-based synchronization instead of time-based

### Challenge: Visual Change Detection
- **Problem**: Basic file size comparison may not detect subtle movements
- **Solution**: Implement pixel difference analysis or triangle position detection
- **Workaround**: Use larger movement distances for reliable detection

### Challenge: Input Method Reliability
- **Problem**: System Events keystroke injection may be unreliable
- **Solution**: Multiple input method options (CGEvents, IOKit, etc.)
- **Validation**: Confirm keystrokes received via application logging

## Platform Considerations

### macOS Implementation
- **Input Method**: AppleScript System Events for keystroke injection
- **Permissions**: Accessibility permissions required for System Events
- **Focus Management**: Application activation via AppleScript
- **Key Codes**: macOS-specific virtual key codes for arrow keys

### Future Cross-Platform Support
- **Linux**: xdotool or similar for keystroke injection
- **Windows**: PowerShell SendKeys or Windows API calls
- **Unified Interface**: Platform detection and appropriate tool selection

## Deliverables

### 1. Enhanced WGPU Application
- Modified triangle renderer with keyboard input handling
- Position state management and uniform updates
- Boundary handling and smooth movement

### 2. Input Automation Tools
- `agent-tools/input-injector.sh` - Keystroke injection utility
- Cross-platform key code mappings
- Focus management and error handling

### 3. Visual Validation Framework
- `agent-tools/movement-validator.sh` - Automated movement testing
- Before/after screenshot comparison
- Test result reporting and analysis

### 4. Testing Suite
- Comprehensive test scenarios for all movement directions
- Automated test runner with result validation
- Performance and reliability metrics

### 5. Documentation
- Usage guide for input automation tools
- Test scenario documentation
- Troubleshooting guide for common issues

## Time Estimate
6-8 hours for complete implementation, testing, and validation

## Priority
**High** - Essential for advancing interactive graphics development and validating agent-assisted testing workflows

## Dependencies
- Enhanced screenshot tool from TOOL-002 (completed)
- Running WGPU triangle application
- macOS System Events accessibility permissions
- Rust winit library for input handling

## Success Metrics

### Before (Current State)
- Static triangle display with no interactivity
- Manual visual verification only
- No automated testing capability
- Limited agent development workflow

### After (Target State)
- **Interactive triangle** responding to arrow key input
- **Automated input injection** via command line tools
- **Visual validation** using screenshot comparison
- **Complete test automation** for input → visual verification workflow

## Integration with Development Workflow

This ticket enables a new pattern for agent-assisted graphics development:

```bash
# Agent workflow example:
./input-injector.sh "viklings-wgpu" up_arrow
./screenshot.sh "viklings-wgpu" "after-up-movement"  
./movement-validator.sh up 126
# Result: Automated verification that up arrow moved triangle upward
```

This creates a foundation for more complex interactive feature development with full automation support.

## Created By
Development Agent (DEV-002)

## Created Date
2025-08-29

## Related Tickets
- **TOOL-001**: Basic screenshot functionality (prerequisite)
- **TOOL-002**: Enhanced window capture (prerequisite) 
- **ARCH-002**: WGPU triangle renderer (foundation)